<!DOCTYPE html>
<html>
<head>
    <title>Symmetry</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&family=Share+Tech+Mono&family=Press+Start+2P&display=swap');

        @font-face {
            font-family: 'Minecraft';
            src: url('https://cdn.jsdelivr.net/npm/minecraft-font@1.0.0/MinecraftRegular-Bmg3.otf');
        }

        :root {
            --bg-color: #000000;
            --text-color: #FFB300;
            --user-color: #00a2ff;
            --border-color: #FFB300;
            --text-shadow: 0 0 12px rgba(255, 179, 0, 0.8);
            --text-glow: 0 0 15px rgba(255, 179, 0, 0.7);
            --user-text-color: #00ffff;
        }

        :root[data-theme="green"] {
            --bg-color: #000000;
            --text-color: #00ff00;
            --user-color: #00ffaa;
            --border-color: #00ff00;
            --text-shadow: 0 0 12px rgba(0, 255, 0, 0.8);
            --text-glow: 0 0 15px rgba(0, 255, 0, 0.7);
        }

        :root[data-theme="green-inverse"] {
            --bg-color: #00ff00;
            --text-color: #000000;
            --user-color: #006644;
            --border-color: #000000;
            --text-shadow: none;
            --text-glow: none;
        }

        :root[data-theme="purple"] {
            --bg-color: #000000;
            --text-color: #b700ff;
            --user-color: #00ffea;
            --border-color: #b700ff;
            --text-shadow: 0 0 12px rgba(183, 0, 255, 0.8);
            --text-glow: 0 0 15px rgba(183, 0, 255, 0.7);
        }

        :root[data-theme="purple-inverse"] {
            --bg-color: #b700ff;
            --text-color: #000000;
            --user-color: #006257;
            --border-color: #000000;
            --text-shadow: none;
            --text-glow: none;
        }

        :root[data-theme="white"] {
            --bg-color: #000000;
            --text-color: #ffffff;
            --user-color: #00ffea;
            --border-color: #ffffff;
            --text-shadow: 0 0 12px rgba(255, 255, 255, 0.8);
            --text-glow: 0 0 15px rgba(255, 255, 255, 0.7);
        }

        :root[data-theme="white-inverse"] {
            --bg-color: #ffffff;
            --text-color: #000000;
            --user-color: #006257;
            --border-color: #000000;
            --text-shadow: none;
            --text-glow: none;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'VT323', monospace;
            font-size: 32px;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
        }

        #container {
            width: calc(100% - 100px);
            height: calc(100% - 100px);
            margin: 50px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #header {
            position: fixed;
            top: 50px;
            left: 50px;
            width: calc(100% - 100px);
            height: 60px;
            background-color: var(--bg-color);
            border-bottom: 2px solid var(--border-color);
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
            font-family: 'VT323', monospace;
        }

        #header-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            color: var(--text-color);
        }

        #title {
            font-size: 32px;
            margin-right: 20px;
            flex: 1;
            text-align: left;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        #clock {
            font-size: 32px;
            margin: 0 20px;
            flex: 1;
            text-align: center;
        }

        #user-code {
            font-size: 32px;
            margin-left: 20px;
            flex: 1;
            text-align: right;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 15px;
        }

        #user-avatar {
            width: 56px;
            height: 56px;
            image-rendering: pixelated;
            border: 2px solid var(--border-color);
            display: none;
            background-color: var(--bg-color);
            box-shadow: 0 0 10px var(--text-glow);
            margin-top: -5px;
        }

        #clock.glitch {
            animation: glitch 0.3s infinite;
        }

        #user-code {
            font-size: 32px;
            margin-left: 20px;
        }

        @keyframes glitch {
            0% { opacity: 1; transform: translate(0); }
            20% { opacity: 0.8; transform: translate(-2px, 2px); }
            40% { opacity: 0.9; transform: translate(2px, -2px); }
            60% { opacity: 0.8; transform: translate(-1px); }
            80% { opacity: 0.9; transform: translate(1px); }
            100% { opacity: 1; transform: translate(0); }
        }

        @keyframes intensiveGlitch {
            0% { transform: translate(0); filter: none; }
            10% { transform: translate(-2px, 2px); filter: hue-rotate(90deg); }
            20% { transform: translate(2px, -2px); filter: invert(0.5); }
            30% { transform: translate(-1px, -1px); filter: saturate(200%); }
            40% { transform: translate(1px, 1px); filter: hue-rotate(-90deg); }
            50% { transform: translate(-2px); filter: brightness(150%); }
            60% { transform: translate(2px); filter: contrast(200%); }
            70% { transform: translate(0, 2px); filter: blur(1px); }
            80% { transform: translate(2px, 0); filter: invert(0.8); }
            90% { transform: translate(-2px, -2px); filter: hue-rotate(180deg); }
            100% { transform: translate(0); filter: none; }
        }

        #clock.intensive-glitch {
            animation: intensiveGlitch 0.2s infinite;
        }

        #terminal {
            margin-top: 80px;
            width: 100%;
            height: calc(100vh - 200px);
            background-color: var(--bg-color);
            padding: 20px;
            overflow-y: auto;
            font-family: 'VT323', monospace;
            font-size: 32px;
            color: var(--text-color);
            position: relative;
        }

        #output {
            margin-bottom: 20px;
        }

        .line {
            margin: 5px 0;
            color: var(--text-color);
            text-shadow: var(--text-shadow);
        }

        .bot-line {
            color: var(--text-color);
            margin: 5px 0;
            text-shadow: var(--text-shadow);
        }

        .user-line {
            color: var(--user-text-color);
            margin: 5px 0;
            text-shadow: var(--text-shadow);
        }

        .input-line {
            display: flex;
            align-items: center;
            margin: 10px 0;
            font-family: 'VT323', monospace;
            font-size: 32px;
            color: var(--text-color);
            text-shadow: var(--text-shadow);
        }

        .input-line input {
            background: transparent;
            border: none;
            color: var(--user-text-color);
            font-family: 'VT323', monospace;
            font-size: 32px;
            margin-left: 10px;
            width: calc(100% - 30px);
            outline: none;
            text-shadow: var(--text-shadow);
        }

        .prompt {
            color: var(--text-color);
            text-shadow: var(--text-shadow);
        }

        .cursor {
            display: inline-block;
            width: 12px;
            height: 32px;
            background-color: var(--text-color);
            margin-left: 5px;
            animation: blink 1s infinite;
            box-shadow: var(--text-glow);
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0; }
        }

        .hidden {
            display: none;
        }

        #webcam-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: var(--bg-color);
            padding: 20px;
            border: 2px solid var(--border-color);
            display: none;
        }

        #webcam {
            width: 640px;
            height: 480px;
            background: #111;
        }

        .countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            color: var(--text-color);
            text-shadow: 0 0 20px rgba(255, 179, 0, 0.5);
            z-index: 1001;
        }

        .processing::after {
            content: '▰▱▱▱▱▱▱▱';
            animation: processing 2s infinite;
            margin-left: 10px;
            color: var(--text-color);
        }

        @keyframes processing {
            0% { content: '▰▱▱▱▱▱▱▱'; }
            12.5% { content: '▰▰▱▱▱▱▱▱'; }
            25% { content: '▰▰▰▱▱▱▱▱'; }
            37.5% { content: '▰▰▰▰▱▱▱▱'; }
            50% { content: '▰▰▰▰▰▱▱▱'; }
            62.5% { content: '▰▰▰▰▰▰▱▱'; }
            75% { content: '▰▰▰▰▰▰▰▱'; }
            87.5% { content: '▰▰▰▰▰▰▰▰'; }
            100% { content: '▰▱▱▱▱▱▱▱'; }
        }

        .rainbow-mode .bot-line,
        .rainbow-mode .prompt {
            animation: rainbow 5s linear infinite;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        .rainbow-mode .user-line {
            animation: rainbow 5s linear infinite reverse;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        .rainbow-mode #userInput {
            animation: rainbow 5s linear infinite reverse;
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }

        .rainbow-mode .cursor {
            animation: rainbow 5s linear infinite reverse, blink 1s infinite;
        }

        @keyframes rainbow {
            0% { color: #ff0000; } /* Red */
            14% { color: #ff7f00; } /* Orange */
            28% { color: #ffff00; } /* Yellow */
            42% { color: #00ff00; } /* Green */
            56% { color: #0000ff; } /* Blue */
            70% { color: #4b0082; } /* Indigo */
            84% { color: #8f00ff; } /* Violet */
            100% { color: #ff0000; } /* Back to red */
        }

        .generated-image {
            max-width: 100%;
            height: auto;
            margin: 10px 0;
            border: 2px solid var(--border-color);
            box-shadow: 0 0 10px rgba(255, 179, 0, 0.3);
        }

        .prompt-text {
            font-style: italic;
            margin: 5px 0 20px 0;
            padding: 10px;
            border-left: 2px solid var(--border-color);
            color: var(--text-color);
            text-shadow: var(--text-shadow);
        }

        .matrix-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            z-index: 1000;
            font-family: 'VT323', monospace;
            font-size: 32px;
            color: #0f0;
        }

        .rain-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 1000;
            font-family: 'VT323', monospace;
            font-size: 32px;
            color: #00a2ff;
        }

        .mandelbrot-effect {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            z-index: 1000;
            font-family: monospace;
            font-size: 8px;
            color: #fff;
            line-height: 6px;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.9);
        }

        .modal-content {
            position: relative;
            margin: auto;
            padding: 20px;
            width: 80%;
            max-width: 700px;
            text-align: center;
        }

        #countdown {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 120px;
            color: white;
            z-index: 1001;
            font-family: 'VT323', monospace;
            text-shadow: 0 0 10px var(--text-color);
        }

        #video {
            width: 100%;
            max-width: 640px;
            margin: auto;
            display: block;
        }

        .line, .bot-line, .user-line {
            text-shadow: var(--text-shadow);
            position: relative;
        }

        .line::after, .bot-line::after, .user-line::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            box-shadow: var(--text-glow);
            opacity: 0.6;
            z-index: -1;
        }
    </style>
</head>
<body>
    <div id="photoModal" class="modal">
        <div class="modal-content">
            <div id="countdown">3</div>
            <video id="video" autoplay></video>
            <canvas id="canvas" style="display: none;"></canvas>
            <canvas id="pixelCanvas" style="display: none;"></canvas>
        </div>
    </div>

    <div id="container">
        <div id="header">
            <div id="header-content">
                <div id="title">T-Symmetry OS</div>
                <div id="clock">00:00:00</div>
                <div id="user-code">
                    <span id="code-text"></span>
                    <img id="user-avatar" alt="User Avatar">
                </div>
            </div>
        </div>
        <div id="terminal">
            <div id="output"></div>
            <div class="input-line" style="display: flex;">
                <span class="prompt">&gt;</span>
                <input type="text" id="userInput" autofocus>
            </div>
        </div>
        <div id="webcam-container" style="display: none;">
            <video id="webcam" autoplay></video>
            <canvas id="canvas"></canvas>
            <button id="capture">Scatta Foto</button>
            <button id="skip">Salta</button>
        </div>
    </div>

    <script>
        const questions = [
            "Con chi ho il piacere di parlare?",
            "Hai piacere che ti scatti una foto per personalizzare ulteriormente l'esperienza?",
            "Ok, adesso che siamo in confidenza, mi vuoi parlare di un tuo ricordo d'infanzia? Descrivilo minuziosamente...",
            "E c'è qualche avvenimento recente che vorresti raccontarmi?",
            "Hai avuto una vita ricca finora. Non avere paura del tempo! Adesso prova a immaginarti in vecchiaia, immagina una scena che ti veda protagonista."
        ];

        let currentQuestionIndex = 0;
        let answers = new Array(questions.length).fill(undefined);
        let userCode = '';
        let photoBlob = null;
        
        // Elementi DOM
        const conversation = document.getElementById('output');
        const inputContainer = document.querySelector('.input-line');
        const userInput = document.getElementById('userInput');
        const webcamContainer = document.getElementById('webcam-container');
        const clockElement = document.getElementById('clock');
        const userCodeElement = document.getElementById('code-text');
        const userAvatar = document.getElementById('user-avatar');
        const modal = document.getElementById('photoModal');
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const countdown = document.getElementById('countdown');
        
        function addBotLine(text, isProcessing = false) {
            const line = document.createElement('div');
            line.className = 'bot-line';
            if (isProcessing) {
                line.innerHTML = `<span class="bot-prompt">&gt;</span> ${text}<span class="processing-dots">...</span>`;
            } else {
                line.innerHTML = `<span class="bot-prompt">&gt;</span> ${text}`;
            }
            conversation.appendChild(line);
            window.scrollTo(0, document.body.scrollHeight);
            return line;
        }

        function addUserLine(text) {
            const line = document.createElement('div');
            line.className = 'line user-line';
            line.textContent = text;
            line.style.color = 'var(--user-text-color)';
            conversation.appendChild(line);
            conversation.scrollTop = conversation.scrollHeight;
        }

        function handleInput(event) {
            if (event.key === 'Enter' && userInput.value.trim() !== '') {
                const command = userInput.value.trim().toLowerCase();
                const text = userInput.value;
                addUserLine(text);
                userInput.value = '';
                
                // Comando start per refresh
                if (command === 'start') {
                    window.location.reload();
                    return;
                }
                
                // Theme commands
                let isThemeCommand = true;
                let feedbackMessage = '';
                
                if (command === 'green') {
                    document.documentElement.setAttribute('data-theme', 'green');
                    feedbackMessage = 'Ho impostato un tema: verde';
                } else if (command === 'purple') {
                    document.documentElement.setAttribute('data-theme', 'purple');
                    feedbackMessage = 'Ho impostato un tema: viola';
                } else if (command === 'white') {
                    document.documentElement.setAttribute('data-theme', 'white');
                    feedbackMessage = 'Ho impostato un tema: bianco';
                } else if (command === 'invert') {
                    const currentTheme = document.documentElement.getAttribute('data-theme') || 'white';
                    if (currentTheme.includes('-inverse')) {
                        document.documentElement.setAttribute('data-theme', currentTheme.replace('-inverse', ''));
                        feedbackMessage = 'Ho ripristinato il tema normale';
                    } else {
                        document.documentElement.setAttribute('data-theme', currentTheme + '-inverse');
                        feedbackMessage = 'Ho invertito i colori del tema';
                    }
                } else {
                    isThemeCommand = false;
                }

                if (isThemeCommand) {
                    addBotLine(feedbackMessage);
                } else {
                    // Gestione normale delle domande
                    if (currentQuestionIndex === 1) {  // Seconda domanda (foto)
                        const positiveResponses = ['sì', 'si', 'yes', 'ok', 'certo'];
                        if (positiveResponses.some(response => command.includes(response))) {
                            answers[currentQuestionIndex] = text;  // Memorizza la risposta nell'indice corretto
                            handlePhoto();
                        } else {
                            answers[currentQuestionIndex] = text;  // Memorizza la risposta nell'indice corretto
                            currentQuestionIndex++;
                            setTimeout(askQuestion, 1000);
                        }
                    } else if (currentQuestionIndex < questions.length) {
                        answers[currentQuestionIndex] = text;  // Memorizza la risposta nell'indice corretto
                        currentQuestionIndex++;
                        if (currentQuestionIndex < questions.length) {
                            setTimeout(askQuestion, 1000);
                        } else {
                            setTimeout(processAllAnswers, 1000);
                        }
                    }
                }
            }
        }

        function askQuestion() {
            if (currentQuestionIndex < questions.length) {
                addBotLine(questions[currentQuestionIndex]);
            }
        }

        async function processAllAnswers() {
            // Verifica che abbiamo tutte le risposte necessarie
            if (answers.length !== questions.length) {
                console.error('Numero di risposte non valido');
                return;
            }

            // Rimuovi eventuali buchi nell'array delle risposte
            const validAnswers = answers.filter(answer => answer !== undefined);
            if (validAnswers.length !== questions.length) {
                console.error('Alcune risposte sono mancanti');
                return;
            }

            const processingLine = addBotLine('Elaborazione delle risposte in corso...', true);
            
            try {
                console.log('Sending data:', {
                    answers: validAnswers,
                    user_code: userCode,
                    photo: photoBlob ? 'present' : 'not present'
                });

                const formData = new FormData();
                formData.append('answers', JSON.stringify(validAnswers));
                formData.append('user_code', userCode);
                
                if (photoBlob) {
                    formData.append('photo', photoBlob, 'user_photo.jpg');
                }

                for (let pair of formData.entries()) {
                    console.log('FormData entry:', pair[0], pair[1]);
                }
                
                const response = await fetch('/process_answers/', {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': getCookie('csrftoken')
                    },
                    body: formData
                });
                
                const data = await response.json();
                console.log('Server response:', data);
                
                if (data.error) {
                    throw new Error(data.error);
                }
                
                processingLine.remove();
                addBotLine(`Ho generato correttamente il tuo profilo, sei il codice: ${userCode}`);
                
                try {
                    console.log('Fetching JSON file:', data.json_file);
                    const jsonResponse = await fetch('/json/' + data.json_file);
                    
                    if (!jsonResponse.ok) {
                        throw new Error(`HTTP error! status: ${jsonResponse.status}`);
                    }
                    
                    const jsonContent = await jsonResponse.json();
                    console.log('JSON content:', jsonContent);
                    
                    if (jsonContent.error) {
                        throw new Error(jsonContent.error);
                    }
                    
                    addBotLine('Ecco il contenuto del tuo profilo:');
                    addBotLine('<pre>' + JSON.stringify(jsonContent, null, 2) + '</pre>');
                } catch (jsonError) {
                    console.error('Error loading JSON:', jsonError);
                    addBotLine('Non sono riuscito a caricare il contenuto del profilo.');
                }
                
                setTimeout(() => {
                    addBotLine('Digita "start" per ricominciare...');
                }, 1000);
                
            } catch (error) {
                console.error('Error:', error);
                processingLine.remove();
                addBotLine('Si è verificato un errore durante l\'elaborazione.');
            }
        }

        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        // Funzione per gestire la fotocamera
        async function handlePhoto() {
            try {
                const modal = document.getElementById('photoModal');
                const video = document.getElementById('video');
                const canvas = document.getElementById('canvas');
                const countdown = document.getElementById('countdown');
                const userAvatar = document.getElementById('user-avatar');
                modal.style.display = 'block';

                navigator.mediaDevices.getUserMedia({ video: true })
                    .then(function(stream) {
                        video.srcObject = stream;
                        video.play();

                        let count = 3;
                        countdown.textContent = count;
                        
                        const countdownInterval = setInterval(() => {
                            count--;
                            countdown.textContent = count;
                            
                            if (count === 0) {
                                clearInterval(countdownInterval);
                                
                                // Scatta la foto dopo il countdown
                                setTimeout(() => {
                                    canvas.width = video.videoWidth;
                                    canvas.height = video.videoHeight;
                                    canvas.getContext('2d').drawImage(video, 0, 0);
                                    
                                    // Ferma il video e rilascia la fotocamera
                                    stream.getTracks().forEach(track => track.stop());
                                    video.srcObject = null;
                                    
                                    // Applica l'effetto pixelato
                                    const pixelatedCanvas = pixelateImage(canvas);
                                    
                                    // Mostra l'avatar
                                    userAvatar.src = pixelatedCanvas.toDataURL('image/png');
                                    userAvatar.style.display = 'block';
                                    
                                    // Converti l'immagine in blob per il salvataggio
                                    pixelatedCanvas.toBlob(function(blob) {
                                        photoBlob = blob;
                                        modal.style.display = 'none';
                                        
                                        // Procedi con la prossima domanda
                                        setTimeout(askQuestion, 1000);
                                    }, 'image/jpeg', 0.8);
                                }, 500);
                            }
                        }, 1000);
                    })
                    .catch(function(error) {
                        console.error('Error accessing camera:', error);
                        modal.style.display = 'none';
                        setTimeout(askQuestion, 1000);
                    });
            } catch (error) {
                console.error('Error in handlePhoto:', error);
                modal.style.display = 'none';
                setTimeout(askQuestion, 1000);
            }
        }

        function pixelateImage(sourceCanvas) {
            const ctx = sourceCanvas.getContext('2d');
            const pixelCanvas = document.getElementById('pixelCanvas');
            const pixelCtx = pixelCanvas.getContext('2d');
            
            // Imposta le dimensioni del canvas pixelato
            const targetWidth = 24;
            const targetHeight = 24;
            
            // Imposta le dimensioni dei canvas
            pixelCanvas.width = targetWidth;
            pixelCanvas.height = targetHeight;
            
            // Prima passiamo a una risoluzione più bassa
            pixelCtx.drawImage(sourceCanvas, 0, 0, targetWidth, targetHeight);
            
            // Ottieni i dati dell'immagine per processarli
            const imageData = pixelCtx.getImageData(0, 0, targetWidth, targetHeight);
            const data = imageData.data;
            
            // Calcola la luminosità media per ogni pixel e applica il colore del tema
            const computedStyle = getComputedStyle(document.documentElement);
            const themeColor = computedStyle.getPropertyValue('--text-color').trim();
            
            // Converti il colore del tema in RGB
            let themeRGB;
            if (themeColor.startsWith('#')) {
                const r = parseInt(themeColor.slice(1, 3), 16);
                const g = parseInt(themeColor.slice(3, 5), 16);
                const b = parseInt(themeColor.slice(5, 7), 16);
                themeRGB = [r, g, b];
            } else if (themeColor.startsWith('rgb')) {
                themeRGB = themeColor.match(/\d+/g).map(Number);
            } else {
                themeRGB = [255, 179, 0]; // Colore di fallback
            }
            
            // Applica il colore del tema a ogni pixel con una scala di colore più ampia
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] * 0.299 + data[i + 1] * 0.587 + data[i + 2] * 0.114) / 255;
                
                // Usa la luminosità per creare una scala di colore più ricca
                if (brightness < 0.2) {
                    // Zone molto scure: colore più scuro del tema
                    data[i] = themeRGB[0] * 0.2;
                    data[i + 1] = themeRGB[1] * 0.2;
                    data[i + 2] = themeRGB[2] * 0.2;
                } else if (brightness > 0.8) {
                    // Zone molto chiare: colore più luminoso del tema
                    data[i] = themeRGB[0];
                    data[i + 1] = themeRGB[1];
                    data[i + 2] = themeRGB[2];
                } else {
                    // Zone intermedie: scala del colore del tema
                    const colorIntensity = (brightness - 0.2) / 0.6;
                    data[i] = themeRGB[0] * colorIntensity;
                    data[i + 1] = themeRGB[1] * colorIntensity;
                    data[i + 2] = themeRGB[2] * colorIntensity;
                }
                data[i + 3] = 255; // Alpha sempre al massimo
            }
            
            // Applica i dati modificati al canvas
            pixelCtx.putImageData(imageData, 0, 0);
            
            // Poi torniamo a 56x56 per l'avatar finale
            ctx.clearRect(0, 0, sourceCanvas.width, sourceCanvas.height);
            sourceCanvas.width = 56;
            sourceCanvas.height = 56;
            
            // Disegna l'immagine pixelata scalandola su
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(pixelCanvas, 0, 0, 56, 56);
            
            return sourceCanvas;
        }

        // Funzione per ottenere il codice utente all'inizio
        async function getUserCode() {
            try {
                const response = await fetch('/get_user_code/', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCookie('csrftoken')
                    }
                });
                const data = await response.json();
                if (data.user_code) {
                    userCode = data.user_code;
                    updateUserCode(userCode);
                }
            } catch (error) {
                console.error('Error getting user code:', error);
            }
        }

        // Funzione per aggiornare il codice utente nell'header
        function updateUserCode(code) {
            const userCodeElement = document.getElementById('code-text');
            if (userCodeElement) {
                userCodeElement.textContent = `SEI IL CODICE: ${code}`;
            }
        }

        // Inizializza il codice utente all'avvio
        document.addEventListener('DOMContentLoaded', () => {
            // Imposta il tema bianco come default
            document.documentElement.setAttribute('data-theme', 'white');
            // Ottieni il codice utente
            getUserCode();
            
            // Avvia l'orologio
            updateClock();
            setInterval(updateClock, 1000);
            
            // Inizia con la prima domanda
            setTimeout(askQuestion, 1000);
            userInput.focus();
        });

        // Gestione orologio con glitch
        let isGlitching = false;
        let timeDirection = 1; // 1 per avanti, -1 per indietro
        let fakeDate = new Date();
        
        function updateClock() {
            if (!isGlitching) {
                const now = new Date();
                clockElement.textContent = now.toLocaleTimeString('it-IT', { 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    second: '2-digit',
                    hour12: false 
                });
            } else {
                fakeDate.setSeconds(fakeDate.getSeconds() + timeDirection);
                clockElement.textContent = fakeDate.toLocaleTimeString('it-IT', { 
                    hour: '2-digit', 
                    minute: '2-digit', 
                    second: '2-digit',
                    hour12: false 
                });
            }
        }

        function startGlitchSequence() {
            if (!isGlitching) {
                isGlitching = true;
                fakeDate = new Date();
                
                // Fase 1: Tempo all'indietro (1 secondo)
                timeDirection = -1;
                setTimeout(() => {
                    // Fase 2: Tempo in avanti (1 secondo)
                    timeDirection = 1;
                    setTimeout(() => {
                        // Fase 3: Glitch intensivo (0.5 secondi)
                        clockElement.classList.add('intensive-glitch');
                        setTimeout(() => {
                            // Fine sequenza
                            clockElement.classList.remove('intensive-glitch');
                            isGlitching = false;
                        }, 500);
                    }, 1000);
                }, 1000);
            }
        }

        // Event listeners
        userInput.addEventListener('keypress', handleInput);
    </script>
</body>
</html>
